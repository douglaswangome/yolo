<ul>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">services</code>:</strong> This is the core section where you define each individual container (service) that makes up your application. Each service corresponds to a container that Docker Compose will manage.</li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">build</code>:</strong>
                <ul class="list-circle list-inside ml-4">
                    <li class="mb-1"><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">context</code>: Specifies the path to the directory containing the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">Dockerfile</code> and the application code needed for building the image.</li>
                    <li><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">dockerfile</code>: (Optional) Specifies the name of the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">Dockerfile</code> if it's not the default <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">Dockerfile</code>.</li>
                </ul>
            </li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">container_name</code>:</strong> Assigns a specific, human-readable name to the container instance. This makes it easier to identify and manage the container using <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">docker ps</code> or <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">docker logs</code>.</li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">ports</code>:</strong> Maps ports from your host machine to the container's exposed ports.
                <ul class="list-circle list-inside ml-4">
                    <li>Example: <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">"5000:5000"</code> means traffic on port <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">5000</code> on your host machine will be forwarded to port <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">5000</code> inside the container.</li>
                </ul>
            </li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">env_file</code>:</strong> This attribute specifies one or more files from which to load environment variables into the service's container.
                <ul class="list-circle list-inside ml-4">
                    <li><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">./backend/.env</code>: In this configuration, Docker Compose will look for a <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">.env</code> file inside your <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend</code> directory (relative to the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">docker-compose.yaml</code> file) and inject all key-value pairs found there as environment variables into the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend</code> container. This is crucial for keeping sensitive information like database connection strings out of your <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">Dockerfile</code> and <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">docker-compose.yaml</code>.</li>
                </ul>
            </li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">networks</code>:</strong> This section defines which Docker networks a service will connect to.
                <ul class="list-circle list-inside ml-4">
                    <li><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">ip2-network</code>: Both <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend</code> and <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">client</code> services are connected to this custom network. This allows them to communicate with each other using their service names (e.g., the client can make requests to <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">http://backend:5000</code> without needing to know the backend container's IP address). Using a custom network provides better isolation and easier service discovery compared to Docker's default bridge network.</li>
                </ul>
            </li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">volumes</code>:</strong> This attribute is used for data persistence and sharing between the host and containers, or between containers.
                <ul class="list-circle list-inside ml-4">
                    <li class="mb-1"><strong>Named Volumes (<code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend_node_modules</code>, <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">client_node_modules</code>):</strong> These are Docker-managed volumes that persist data even if the containers are removed. They are ideal for caching dependencies like <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">node_modules</code>. By mounting <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend_node_modules:/app/node_modules</code>, Docker will store the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">node_modules</code> directory for the backend in a persistent volume. This means <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">npm ci</code> won't have to re-download all dependencies every time you rebuild or restart the container, significantly speeding up development iterations. The same applies to <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">client_node_modules</code>.</li>
                    <li><strong>Bind Mounts (Implicitly removed in your latest YAML, but common for dev)</strong>: While not in your provided YAML, often in development, you'd also include bind mounts like <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">./backend:/app</code> and <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">./client:/app</code>. These directly link a directory on your host machine to a directory inside the container. This is useful for live development, as changes made to your code on the host are immediately reflected in the container without needing to rebuild the image.</li>
                </ul>
            </li>
            <li class="mb-2"><strong><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">depends_on</code>:</strong> This specifies that a service depends on another service. Docker Compose will start the dependencies in the correct order.
                <ul class="list-circle list-inside ml-4">
                    <li><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">depends_on: - backend</code>: Ensures that the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">backend</code> service is started and running before the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">client</code> service attempts to start. This is important to prevent the client from failing if it tries to connect to a backend that isn't yet available.</li>
                </ul>
            </li>
            <li class="mb-2"><strong>Top-level <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">networks</code> section:</strong> This is where you define the custom networks used by your services.
                <ul class="list-circle list-inside ml-4">
                    <li><code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">ip2-network</code>: Declares a new network named <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">ip2-network</code> with the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">bridge</code> driver. This creates a virtual network that services can join.</li>
                </ul>
            </li>
            <li class="mb-2"><strong>Top-level <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">volumes</code> section:</strong> This is where you declare the named volumes that your services will use. Declaring them here makes them available for use by any service in the <code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded-md text-sm">docker-compose.yaml</code>.</li>
        </ul>